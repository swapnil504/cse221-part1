# -*- coding: utf-8 -*-
"""lab_file

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AhGFi2LObBSYWCannaHxug_p0erZ04UO
"""

#lab8

import sys

def main():
    N, K = map(int, sys.stdin.readline().split())
    parent = {}
    size = {}

    def find(u):
        while parent[u] != u:
            parent[u] = parent[parent[u]]
            u = parent[u]
        return u

    for _ in range(K):
        a, b = map(int, sys.stdin.readline().split())
        if a not in parent:
            parent[a] = a
            size[a] = 1
        if b not in parent:
            parent[b] = b
            size[b] = 1

        root_a = find(a)
        root_b = find(b)

        if root_a != root_b:
            if size[root_a] < size[root_b]:
                root_a, root_b = root_b, root_a
            parent[root_b] = root_a
            size[root_a] += size[root_b]
            print(size[root_a])
        else:
            print(size[root_a])

if __name__ == "__main__":
    main()








  -----------------------------------------------------------
  import sys

def main():
    data = sys.stdin.read().split()
    ptr = 0
    N = int(data[ptr])
    ptr += 1
    M = int(data[ptr])
    ptr += 1

    edges = []
    for _ in range(M):
        u = int(data[ptr])
        ptr += 1
        v = int(data[ptr])
        ptr += 1
        cost = int(data[ptr])
        ptr += 1
        edges.append((cost, u, v))

    edges.sort()

    parent = {}
    rank = {}

    def find(u):
        while parent[u] != u:
            parent[u] = parent[parent[u]]
            u = parent[u]
        return u

    total = 0
    for cost, u, v in edges:
        if u not in parent:
            parent[u] = u
            rank[u] = 1
        if v not in parent:
            parent[v] = v
            rank[v] = 1

        root_u = find(u)
        root_v = find(v)

        if root_u != root_v:
            if rank[root_u] < rank[root_v]:
                parent[root_u] = root_v
            else:
                parent[root_v] = root_u
                if rank[root_u] == rank[root_v]:
                    rank[root_u] += 1
            total += cost

    print(total)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------

import sys
import math
from collections import deque

data = sys.stdin.read().split()
if not data:
    sys.exit()
it = iter(data)
n = int(next(it))
m = int(next(it))
edges = []
for _ in range(m):
    u = int(next(it))
    v = int(next(it))
    w = int(next(it))
    edges.append((w,u,v))
edges.sort(key=lambda x: x[0])

parent = list(range(n+1))
rank = [0]*(n+1)
def find(x):
    while parent[x] != x:
        parent[x] = parent[parent[x]]
        x = parent[x]
    return x

def union(x,y):
    rx = find(x)
    ry = find(y)
    if rx == ry:
        return False
    if rank[rx] < rank[ry]:
        parent[rx] = ry
    elif rank[rx] > rank[ry]:
        parent[ry] = rx
    else:
        parent[ry] = rx
        rank[rx] += 1
    return True

adj = [[] for _ in range(n+1)]
mst_weight = 0
edge_count = 0
non_mst = []
for w,u,v in edges:
    if union(u,v):
        adj[u].append((v,w))
        adj[v].append((u,w))
        mst_weight += w
        edge_count += 1
    else:
        non_mst.append((u,v,w))
if edge_count < n-1:
    print(-1)
    sys.exit()

LOG = math.ceil(math.log2(n)) + 1
parent_up = [[0]*(n+1) for _ in range(LOG)]
max_up = [[0]*(n+1) for _ in range(LOG)]
depth = [0]*(n+1)

visited = [False]*(n+1)
root = 1
visited[root] = True
depth[root] = 0
parent_up[0][root] = root
max_up[0][root] = 0
dq = deque([root])
while dq:
    u = dq.popleft()
    for v,w in adj[u]:
        if not visited[v]:
            visited[v] = True
            depth[v] = depth[u] + 1
            parent_up[0][v] = u
            max_up[0][v] = w
            dq.append(v)

for i in range(1, LOG):
    for v in range(1, n+1):
        p = parent_up[i-1][v]
        parent_up[i][v] = parent_up[i-1][p]
        max_up[i][v] = max(max_up[i-1][v], max_up[i-1][p])

def get_max_edge(u,v):
    if depth[u] < depth[v]:
        u, v = v, u
    max_edge = 0
    diff = depth[u] - depth[v]
    i = 0
    while diff:
        if diff & 1:
            if max_up[i][u] > max_edge:
                max_edge = max_up[i][u]
            u = parent_up[i][u]
        diff >>= 1
        i += 1
    if u == v:
        return max_edge
    for i in range(LOG-1, -1, -1):
        if parent_up[i][u] != parent_up[i][v]:
            if max_up[i][u] > max_edge:
                max_edge = max_up[i][u]
            if max_up[i][v] > max_edge:
                max_edge = max_up[i][v]
            u = parent_up[i][u]
            v = parent_up[i][v]
    if max_up[0][u] > max_edge:
        max_edge = max_up[0][u]
    if max_up[0][v] > max_edge:
        max_edge = max_up[0][v]
    return max_edge

best2 = float('inf')
for u,v,w in non_mst:
    max_e = get_max_edge(u,v)
    if w > max_e:
        cost = mst_weight + w - max_e
        if cost < best2:
            best2 = cost

if best2 == float('inf'):
    print(-1)
else:
    print(best2)

#lab7
import sys
import heapq

def main():
    data = sys.stdin.read().split()
    ptr = 0
    N = int(data[ptr]); ptr += 1
    M = int(data[ptr]); ptr += 1
    S = int(data[ptr]); ptr += 1
    D = int(data[ptr]); ptr += 1

    u_list = list(map(int, data[ptr:ptr+M]))
    ptr += M
    v_list = list(map(int, data[ptr:ptr+M]))
    ptr += M
    w_list = list(map(int, data[ptr:ptr+M]))
    ptr += M

    adj = [[] for _ in range(N+1)]
    for i in range(M):
        u = u_list[i]
        v = v_list[i]
        w = w_list[i]
        adj[u].append((v, w))

    dist = [float('inf')] * (N + 1)
    prev = [-1] * (N + 1)
    dist[S] = 0
    heap = [(0, S)]
    heapq.heapify(heap)

    found = False
    while heap:
        d_u, u = heapq.heappop(heap)
        if u == D:
            found = True
            break
        if d_u > dist[u]:
            continue
        for v, w in adj[u]:
            if dist[v] > d_u + w:
                dist[v] = d_u + w
                prev[v] = u
                heapq.heappush(heap, (dist[v], v))

    if dist[D] == float('inf'):
        print(-1)
    else:
        print(dist[D])
        path = []
        current = D
        while current != -1:
            path.append(current)
            current = prev[current]
        path.reverse()
        print(' '.join(map(str, path)))

if __name__ == "__main__":
    main()

------------------------------------------------------------------
import sys
import heapq

def main():
    input = sys.stdin.read().split()
    ptr = 0
    N = int(input[ptr]); ptr += 1
    M = int(input[ptr]); ptr += 1
    S = int(input[ptr]); ptr += 1
    T = int(input[ptr]); ptr += 1

    if S == T:
        print(0, S)
        return

    adj = [[] for _ in range(N + 1)]
    for _ in range(M):
        u = int(input[ptr]); ptr += 1
        v = int(input[ptr]); ptr += 1
        w = int(input[ptr]); ptr += 1
        adj[u].append((v, w))

    def dijkstra(start):
        dist = [float('inf')] * (N + 1)
        dist[start] = 0
        heap = [(0, start)]
        heapq.heapify(heap)
        while heap:
            d, u = heapq.heappop(heap)
            if d > dist[u]:
                continue
            for v, w in adj[u]:
                if dist[v] > d + w:
                    dist[v] = d + w
                    heapq.heappush(heap, (dist[v], v))
        return dist

    distA = dijkstra(S)
    distB = dijkstra(T)

    min_time = float('inf')
    best_node = -1
    for u in range(1, N + 1):
        a = distA[u]
        b = distB[u]
        if a == float('inf') or b == float('inf'):
            continue
        current = max(a, b)
        if current < min_time:
            min_time = current
            best_node = u
        elif current == min_time and u < best_node:
            best_node = u

    print(-1 if best_node == -1 else f"{min_time} {best_node}")

if __name__ == "__main__":
    main()
-------------------------------------------------------------------
import sys
import heapq

def main():
    data = sys.stdin.read().split()
    ptr = 0
    N = int(data[ptr])
    ptr += 1
    M = int(data[ptr])
    ptr += 1

    adj = [[] for _ in range(N + 1)]
    for _ in range(M):
        u = int(data[ptr])
        ptr += 1
        v = int(data[ptr])
        ptr += 1
        w = int(data[ptr])
        ptr += 1
        adj[u].append((v, w))
        adj[v].append((u, w))

    dist = [float('inf')] * (N + 1)
    dist[1] = 0
    heap = [(0, 1)]
    heapq.heapify(heap)

    while heap:
        current_max, u = heapq.heappop(heap)
        if current_max > dist[u]:
            continue
        for v, w in adj[u]:
            new_max = max(current_max, w)
            if new_max < dist[v]:
                dist[v] = new_max
                heapq.heappush(heap, (new_max, v))

    result = []
    for i in range(1, N + 1):
        if dist[i] == float('inf'):
            result.append('-1')
        else:
            result.append(str(dist[i]))

    print(' '.join(result))

if __name__ == "__main__":
    main()

#lab6
from collections import deque

N, M = map(int, input().split())
graph = [[] for _ in range(N + 1)]
indegree = [0] * (N + 1)
for i in range(M):
    A, B = map(int, input().split())
    graph[A].append(B)
    indegree[B] += 1

queue = deque()
for i in range(1, N + 1):
    if indegree[i] == 0:
        queue.append(i)

result = []
while queue:
    node = queue.popleft()
    result.append(node)
    for next in graph[node]:
        indegree[next] -= 1
        if indegree[next] == 0:
            queue.append(next)

if len(result) != N:
    print(-1)
else:
    print(*result)
---------------------------------------
from collections import deque

n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)

vis = [False] * (n + 1)
color = [-1] * (n + 1)
ans = 0

for i in range(1, n + 1):
    if not vis[i]:
        q = deque()
        q.append(i)
        vis[i] = True
        color[i] = 0
        count = [1, 0]
        bipartite = True
        while q:
            u = q.popleft()
            for v in adj[u]:
                if not vis[v]:
                    vis[v] = True
                    color[v] = 1 - color[u]
                    count[color[v]] += 1
                    q.append(v)
                elif color[v] == color[u]:
                    bipartite = False
        if bipartite:
            ans += max(count)
print(ans)
---------------------------------------------------#this presents a break through the next code

from collections import deque

N = int(input())
x1, y1, x2, y2 = map(int, input().split())

moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
queue = deque([(x1, y1)])
dist = [[-1] * (N + 1) for _ in range(N + 1)]
dist[x1][y1] = 0

while queue:
    x, y = queue.popleft()
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 1 <= nx <= N and 1 <= ny <= N and dist[nx][ny] == -1:
            dist[nx][ny] = dist[x][y] + 1
            queue.append((nx, ny))

if dist[x2][y2] == -1:
    print(-1)
else:
    print(dist[x2][y2])

#lab5
from collections import deque

def bfs_traversal():
    n, m = map(int, input().split())
    graph = [[] for _ in range(n + 1)]

    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)

    for i in range(1, n + 1):
        graph[i].sort()

    visited = [False] * (n + 1)
    res = []
    q = deque()

    q.append(1)
    visited[1] = True

    while q:
        node = q.popleft()
        res.append(node)
        for nei in graph[node]:
            if not visited[nei]:
                visited[nei] = True
                q.append(nei)

    return res

print(*bfs_traversal())
-----------------------------------------
import sys
from collections import deque

def main():
    data = sys.stdin.read().split()
    ptr = 0
    N = int(data[ptr])
    M = int(data[ptr+1])
    ptr += 2

    u = list(map(int, data[ptr:ptr+M]))
    ptr += M
    v = list(map(int, data[ptr:ptr+M]))

    adj = [[] for _ in range(N+1)]
    for i in range(M):
        a = u[i]
        b = v[i]
        adj[a].append(b)
        adj[b].append(a)

    for neighbors in adj:
        neighbors.sort()

    visited = [False] * (N + 1)
    result = []
    stack = [(1, iter(adj[1]))]
    visited[1] = True
    result.append(1)

    while stack:
        node, neighbors = stack[-1]
        try:
            neighbor = next(neighbors)
            if not visited[neighbor]:
                visited[neighbor] = True
                result.append(neighbor)
                stack.append((neighbor, iter(adj[neighbor])))
        except StopIteration:
            stack.pop()

    print(' '.join(map(str, result)))

if __name__ == "__main__":
    main()
------------------------------------------------------
import sys
from collections import deque

def main():
    input = sys.stdin.read().split()
    ptr = 0
    N = int(input[ptr])
    M = int(input[ptr+1])
    S = int(input[ptr+2])
    D = int(input[ptr+3])
    ptr += 4

    u = list(map(int, input[ptr:ptr+M]))
    ptr += M
    v = list(map(int, input[ptr:ptr+M]))

    adj = [[] for _ in range(N+1)]
    for i in range(M):
        a = u[i]
        b = v[i]
        adj[a].append(b)
        adj[b].append(a)

    for neighbors in adj:
        neighbors.sort()

    dist = [-1]*(N+1)
    parent = [-1]*(N+1)
    q = deque()

    dist[S] = 0
    q.append(S)

    while q:
        current = q.popleft()
        if current == D:
            break
        for neighbor in adj[current]:
            if dist[neighbor] == -1:
                dist[neighbor] = dist[current] + 1
                parent[neighbor] = current
                q.append(neighbor)

    if dist[D] == -1:
        print(-1)
        return

    path = []
    node = D
    while node != -1:
        path.append(node)
        node = parent[node]
    path.reverse()

    print(dist[D])
    print(' '.join(map(str, path)))

if __name__ == "__main__":
    main()

#lab4
n, m = map(int, input().split())
mat = []
for i in range(n):
    row = []
    for j in range(n):
        row.append(0)
    mat.append(row)

for _ in range(m):
    u, v, w = map(int, input().split())
    mat[u - 1][v - 1] = w

for i in range(n):
    for j in range(n):
        print(mat[i][j], end=' ')
    print()
_________________________________________
n, m = map(int, input().split())
u = list(map(int, input().split()))
v = list(map(int, input().split()))
w = list(map(int, input().split()))

adj = []
for i in range(n + 1):
    adj.append([])

for i in range(m):
    adj[u[i]].append((v[i], w[i]))

for i in range(1, n + 1):
    print(str(i) + ":", end='')
    for pair in adj[i]:
        print(" (" + str(pair[0]) + "," + str(pair[1]) + ")", end='')
    print()

#lab3
def merge_count(left, right):
    result = []
    i = j = 0
    inv_count = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            inv_count += len(left) - i
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])

    return result, inv_count

def merge_sort_count(arr):
    if len(arr) <= 1:
        return arr, 0

    mid = len(arr) // 2
    left, left_count = merge_sort_count(arr[:mid])
    right, right_count = merge_sort_count(arr[mid:])

    merged, merge_count_result = merge_count(left, right)

    total_count = left_count + right_count + merge_count_result
    return merged, total_count

n = int(input())
arr = list(map(int, input().split()))

sorted_arr, inversion_count = merge_sort_count(arr)

print(inversion_count)
print(" ".join(map(str, sorted_arr)))
------
def max_pair_value(arr, left, right):
    if left == right:
        return -float('inf')

    if left + 1 == right:
        return arr[left] + arr[right] ** 2

    mid = (left + right) // 2

    left_max = max_pair_value(arr, left, mid)
    right_max = max_pair_value(arr, mid + 1, right)

    max_left = -float('inf')
    max_right = -float('inf')

    for i in range(left, mid + 1):
        if arr[i] > max_left:
            max_left = arr[i]

    for j in range(mid + 1, right + 1):
        if arr[j] ** 2 > max_right:
            max_right = arr[j] ** 2

    cross_max = max_left + max_right

    return max(left_max, right_max, cross_max)

N = int(input())
A = list(map(int, input().split()))
result = max_pair_value(A, 0, N - 1)
print(result)
------------------------------------------
def fast_mod_exp(a, b, mod):
    if b == 0:
        return 1 % mod
    result = 1
    a = a % mod
    while b > 0:
        if b % 2 == 1:
            result = (result * a) % mod
        a = (a * a) % mod
        b = b // 2
    return result

a, b = map(int, input().split())
mod = 107
print(fast_mod_exp(a, b, mod))
------------------------------------------------------
def fast_mod_exp(a, b, mod):
    result = 1
    a = a % mod
    while b > 0:
        if b % 2 == 1:
            result = (result * a) % mod
        a = (a * a) % mod
        b = b // 2
    return result

def geometric_series(a, n, mod):
    if n == 0:
        return 0
    if n == 1:
        return a % mod
    half = n // 2
    if n % 2 == 0:
        return (geometric_series(a, half, mod) * (1 + fast_mod_exp(a, half, mod))) % mod
    else:
        return (geometric_series(a, half, mod) * (1 + fast_mod_exp(a, half, mod)) + fast_mod_exp(a, n, mod)) % mod

T = int(input())
for _ in range(T):
    a, n, m = map(int, input().split())
    print(geometric_series(a, n, m))
---------------------------------------------

#lab2
def find_two_sum(n, target, arr):
    l = 0
    r = n - 1

    while l < r:
        s = arr[l] + arr[r]

        if s == target:
            print(l + 1, r + 1)
            return

        if s < target:
            l += 1
        else:
            r -= 1

    print(-1)

n, target = map(int, input().split())
arr = list(map(int, input().split()))

find_two_sum(n, target, arr)
-------------------------------------------------------
def merge_lists(n, list1, m, list2):
    i = 0
    j = 0
    merged = []

    while i < n and j < m:
        if list1[i] <= list2[j]:
            merged.append(list1[i])
            i += 1
        else:
            merged.append(list2[j])
            j += 1

    while i < n:
        merged.append(list1[i])
        i += 1

    while j < m:
        merged.append(list2[j])
        j += 1

    for num in merged:
        print(num, end=" ")
    print()

n = int(input())
list1 = list(map(int, input().split()))
m = int(input())
list2 = list(map(int, input().split()))

merge_lists(n, list1, m, list2)

#lab1
n=int(input())
for i in range(n):
    num=int(input())
    if(num% 2 == 0):
        print(f"{num} is an Even number.")
    else:
        print(f"{num} is an Odd number.")

#lab2
n=int(input())
for i in range(n):
     m=input().split()
     if(m[2]=='+'):
       print(int(m[1])+int(m[3]))
     elif(m[2]=='-'):
       print(int(m[1])-int(m[3]))
     elif(m[2]=='*'):
       print(int(m[1])*int(m[3]))
     elif(m[2]=='/'):
       print(int(m[1])/int(m[3]))
--------------------------------------
size, k = map(int, input().split())


arr = list(map(int, input().split()))

i = k - 1
while i >= 0:
    print(arr[i], end=" ")
    i -= 1